<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Chapter 7 Models | Experimentology" />
<meta property="og:type" content="book" />





<meta name="author" content="Michael C. Frank, Mika Braginsky, Julie Cachia, Nicholas Coles, Tom Hardwicke, Robert Hawkins, Maya Mathur, and Rondeline Williams" />


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="Chapter 7 Models | Experimentology">

<title>Chapter 7 Models | Experimentology</title>

<script src="libs/header-attrs-2.11/header-attrs.js"></script>
<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script>
<script src="libs/jquery-3.5.1/jquery.min.js"></script>
<link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="libs/datatables-binding-0.18/datatables.js"></script>
<link href="libs/dt-core-1.10.20/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="libs/dt-core-1.10.20/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="libs/dt-core-1.10.20/js/jquery.dataTables.min.js"></script>
<link href="libs/crosstalk-1.1.1/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.1.1/js/crosstalk.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
<link rel="stylesheet" href="toc/toc.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li class="part"><span><b>I Preliminaries</b></span></li>
<li><a href="1-experiments.html#experiments"><span class="toc-section-number">1</span> Experiments</a></li>
<li><a href="2-theories.html#theories"><span class="toc-section-number">2</span> Theories</a></li>
<li><a href="3-replication.html#replication"><span class="toc-section-number">3</span> Replication and reproducibility</a></li>
<li><a href="4-ethics.html#ethics"><span class="toc-section-number">4</span> Ethics</a></li>
<li class="part"><span><b>II Statistics</b></span></li>
<li><a href="5-estimation.html#estimation"><span class="toc-section-number">5</span> Estimation</a></li>
<li><a href="6-inference.html#inference"><span class="toc-section-number">6</span> Inference</a></li>
<li><a href="7-models.html#models"><span class="toc-section-number">7</span> Models</a></li>
<li class="part"><span><b>III Design and Planning</b></span></li>
<li><a href="8-measurement.html#measurement"><span class="toc-section-number">8</span> Measurement</a></li>
<li><a href="9-design.html#design"><span class="toc-section-number">9</span> Design of experiments</a></li>
<li><a href="10-sampling.html#sampling"><span class="toc-section-number">10</span> Sampling</a></li>
<li><a href="11-strategy.html#strategy"><span class="toc-section-number">11</span> Experimental strategy</a></li>
<li class="part"><span><b>IV Execution</b></span></li>
<li><a href="12-prereg.html#prereg"><span class="toc-section-number">12</span> Preregistration</a></li>
<li><a href="13-consent.html#consent"><span class="toc-section-number">13</span> Consent and the ethics of participation</a></li>
<li><a href="14-collection.html#collection"><span class="toc-section-number">14</span> Data collection</a></li>
<li><a href="15-management.html#management"><span class="toc-section-number">15</span> Project management</a></li>
<li class="part"><span><b>V Analysis and Reporting</b></span></li>
<li><a href="16-viz.html#viz"><span class="toc-section-number">16</span> Visualization</a></li>
<li><a href="17-eda.html#eda"><span class="toc-section-number">17</span> Exploratory data analysis</a></li>
<li><a href="18-writing.html#writing"><span class="toc-section-number">18</span> Writing</a></li>
<li><a href="19-meta.html#meta"><span class="toc-section-number">19</span> Meta-analysis</a></li>
<li><a href="20-conclusions.html#conclusions"><span class="toc-section-number">20</span> Conclusions</a></li>
<li class="part"><span><b>VI Appendices</b></span></li>
<li><a href="21-git.html#git"><span class="toc-section-number">21</span> GitHub Tutorial</a></li>
<li><a href="22-rmarkdown.html#rmarkdown"><span class="toc-section-number">22</span> R Markdown Tutorial</a></li>
<li><a href="23-tidyverse.html#tidyverse"><span class="toc-section-number">23</span> Tidyverse Tutorial</a></li>
<li><a href="24-ggplot.html#ggplot"><span class="toc-section-number">24</span> ggplot Tutorial</a></li>
<li><a href="25-instructors.html#instructors"><span class="toc-section-number">25</span> Instructor‚Äôs guide</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="models" class="section level1" number="7">
<h1><span class="header-section-number">Chapter 7</span> Models</h1>
<!-- ```{r models-meme} -->
<!-- knitr::include_graphics("images/models/couldnt_help_it.png") -->
<!-- ``` -->
<div class="learning-goals">
<p>üçé Learning goals:</p>
<ul>
<li>Reconceptualize statistical ‚Äútests‚Äù as models of data</li>
<li>Build intuitions about how specific ‚Äútests‚Äù (e.g., t-tests) relate to more general frameworks (e.g., regression, mixed effects models)</li>
<li>Identify which models are best suited for which research questions</li>
<li>Describe what it means to ‚Äòcontrol for‚Äô something</li>
<li>Explore what kinds of clustered variance are present in our designs</li>
<li>Select models appropriate for different kinds of dependent variables</li>
</ul>
</div>
<p>In the previous two chapters, we introduced concepts surrounding estimation of an experimental effect and inference about its relationship to the effect in the population. The tools we introduced are very general, but they are limited in their applicability. Once you get beyond the world of two-condition experiments in which each participant contributes one data point from a continuous measure, the simple <span class="math inline">\(t\)</span>-test is not sufficient.</p>
<p>In some statistics textbooks, the next step would be to present a whole host of other statistical tests that are designed for other special cases. We could even show a decision-tree: what if you have repeated measures? Or categorical data? Or three conditions? But this isn‚Äôt a statistics book, and even if it were, we don‚Äôt advocate that approach. The idea of finding a specific narrowly-tailored test for your situation is part and parcel of the dichotomous NHST approach that we tried to talk you out of in the last chapter. If all you want is your <span class="math inline">\(p&lt;.05\)</span>, then it makes sense to look up the test that can allow you to compute a <span class="math inline">\(p\)</span> value in your specific case. But we prefer an approach that is more focused on getting a good estimate of the magnitude of the causal effect ‚Äì and the relation of that estimate to the population mean.</p>
<p>In this chapter, we begin to explore how to to go about making these estimates and making inference about them ‚Äì and that brings us to the world of <strong>statistical models</strong>. A statistical model is a way of writing down a set of assumptions about how particular data are generated. Statistical models are the bread and butter tools for estimating particular <strong>parameters</strong> of interest ‚Äì like the magnitude of a causal effect associated with an experimental manipulation ‚Äì and making inferences about their relationship to the population parameter.</p>
<p>For example, a simple statistical model might assume that observed datapoints are generated via with the flip of a weighted coin. Then the process of estimation is to assess the most likely weight of the coin given the data. This model can then be used to make inferences about whether the coin‚Äôs weight differs from some null model (a fair coin, perhaps).</p>
<p>This simple example sounds a lot like the kinds of simple inferential tests we talked about in the previous chapter; not very ‚Äúmodel-y.‚Äù But things get more interesting when there are multiple parameters to be estimated, as in most real-world scenarios. In the tea-tasting scenario we‚Äôve belabored over the past two chapters, a real experiment might involve multiple people tasting different types of tea in different orders, all with some cups randomly assigned to be milk-first or tea-first. What we‚Äôll learn to do in this chapter is to make a model of this situation that allows us to reason about the magnitude of the milk-order effect while also estimating variation due to different people, orders, and tea types.</p>
<p>We‚Äôll begin by discussing the ubiquitous framework for building statistical models, <strong>linear regression</strong>, building up connections between regression and the <span class="math inline">\(t\)</span>-test. This section will discuss how to add covariates to regression models, and when linear regression does and doesn‚Äôt work. In the next section, we‚Äôll discuss the <strong>generalized linear model</strong>, an innovation that allows us to make models of a broader range of data types. We‚Äôll then briefly introduce <strong>mixed models</strong>, which allow us to model clustering in our datasets (such as clusters of observations from a single individual or single stimulus item). We‚Äôll end with some opinionated practical advice on model building.</p>
<div class="case-study">
<p>üî¨ Case study: Stimulus-specific effects</p>
<p>Imagine you‚Äôre a psycholinguist who has the hypothesis that nouns are processed faster than verbs. You run an experiment where you pick out ten verbs and ten nouns, then measure a large sample of participants‚Äô reading time for each of these. You find strong evidence for the predicted effect and publish a paper on your claim. The only problem is that, at the same time, someone else has done exactly the same study ‚Äì with different nouns and verbs ‚Äì and published a paper making the opposite claim. The problem in this example is that each effect is driven by the specific experimental items that were chosen <span class="citation">(<a href="#ref-clark1973" role="doc-biblioref">Clark, 1973</a>)</span>. Out of hundreds of thousands of possible words, why these in particular?</p>
<p>The problem of generalization from sample to population is not new ‚Äì as we discussed in Chapter <a href="6-inference.html#inference">6</a>, we are constantly doing this kind of inference with the samples of people that participate in our experiments. Our classic statistical techniques are designed to generalize from sample to population and we are typically sensitive to the weakness of generalizations made from very small samples of experimental participants. Not so with stimuli.<label for="tufte-sn-86" class="margin-toggle sidenote-number">86</label><input type="checkbox" id="tufte-sn-86" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">86</span> <span class="citation"><a href="#ref-clark1973" role="doc-biblioref">Clark</a> (<a href="#ref-clark1973" role="doc-biblioref">1973</a>)</span>, from whom this example is adapted, calls this the ‚Äúlanguage-as-fixed-effect‚Äù fallacy. This is a great label for folks who already know about fixed vs.¬†random effects, but it doesn‚Äôt highlight how it connects to the braoder set of issues of generalizability that we highlight here and in Chapter <a href="10-sampling.html#sampling">10</a>, so we‚Äôll mostly use the label ‚Äústimulus generalizability.‚Äù</span></p>
<p>Stimulus generalizability problems have reared their head across a surprising range of different areas of psychology. In one example, hundreds of papers were written about a phenomenon called the ‚Äúrisky shift‚Äù ‚Äì in which groups deliberating about a decision would produce riskier decisions than individuals. Unfortunately, this phenomenon appeared to be completely driven by the specific choice of vignettes that groups deliberated about, with some producing a risky shift and others producing a more conservative shift <span class="citation">(<a href="#ref-westfall2015" role="doc-biblioref">Westfall et al., 2015</a>)</span>.</p>
<p>Another example comes from the memory literature, where a classic paper by <span class="citation"><a href="#ref-baddeley1975" role="doc-biblioref">Baddeley et al.</a> (<a href="#ref-baddeley1975" role="doc-biblioref">1975</a>)</span> suggested that words that take longer to pronounce (‚Äútycoon‚Äù or ‚Äúmorphine‚Äù) would be remembered worse than words that took a shorter amount of time (‚Äúember‚Äù or ‚Äúwicket‚Äù) even when they had the same number of syllables. This effect also appears to be driven by the specific sets of words chosen in the original paper; the effect is robustly replicable with that set but not generalizable across other sets <span class="citation">(<a href="#ref-lovatt2000" role="doc-biblioref">Lovatt et al., 2000</a>)</span>.</p>
<p>The implication of these examples is clear: experimenters need to take care in both their experimental design and analysis to avoid overgeneralizing from their stimuli to a broader construct. Three primary steps can help experimenters avoid this pitfall:</p>
<ol style="list-style-type: decimal">
<li>To maximize generality, use samples of experimental items ‚Äì words, pictures, or vignettes ‚Äì that are comparable in size to your samples of participants.</li>
<li>When replicating an experiment, consider taking a new sample of items as well as a new sample of participants.</li>
<li>When experimental items are sampled random from a broader population, always make use of statistical analyses ‚Äì such as the ones described below ‚Äì that control for this sampling process.</li>
</ol>
</div>
<div id="regression-models" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Regression models</h2>
<p>There are many types of statistical models, but this chapter will focus primarily on regression, a broad and extremely powerful class of models. A regression model relates a dependent variable to one or more independent variables. Dependent variables are sometimes called <strong>outcome variables</strong>, and independent variables are sometimes called <strong>predictor variables</strong>, <strong>covariates</strong>, or <strong>features</strong>. We will see that many common statistical estimators (like the sample mean) and methods of inference (like the <span class="math inline">\(t\)</span>-test) are actually simple regression models. Understanding this point will help you see many statistical methods as special cases of the same underlying framework, rather than as unrelated, ad hoc methods.</p>
<div id="regression-for-estimating-a-simple-treatment-effect" class="section level3" number="7.1.1">
<h3><span class="header-section-number">7.1.1</span> Regression for estimating a simple treatment effect</h3>
<!-- : Treatment effect estimation in a two-group experiment -->
<!-- MBM to MCF: Estimation chapter actually foreshadows *Welch's* t-test because it describes unequal vars. Inference chapter generically refers to a t-test without making distinction. Let's discuss. -->
<p>Let‚Äôs start with one of these special cases, namely estimating a treatment effect, <span class="math inline">\(\beta\)</span>, in a two-group design. In Chapter <a href="5-estimation.html#estimation">5</a>, we solved this exact challenge for the tea-tasting experiment. We posited a model in which the milk-first ratings were normally distributed with mean <span class="math inline">\(\theta_{milkfirst} = \theta_{teafirst} + \beta\)</span> and with standard deviation <span class="math inline">\(\sigma_{milkfirst}\)</span>.<label for="tufte-sn-87" class="margin-toggle sidenote-number">87</label><input type="checkbox" id="tufte-sn-87" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">87</span> Here‚Äôs a quick reminder that ‚Äúmodel‚Äù here is a way of saying ‚Äúset of assumptions about the data generating procedure.‚Äù So saying that some equation is a ‚Äúmodel‚Äù is the same as saying, we think this is where the data came from. If we turn the crank that‚Äôs specified in those equations, e.g., pulling numbers from a normal distribution with mean <span class="math inline">\(\theta_{milkfirst}\)</span> and standard deviation <span class="math inline">\(\sigma_{milkfirst}\)</span>, we think we‚Äôll get data that are substantively similar to the ones we have already.</span></p>
<p>Let‚Äôs now write that model as a regression model, that is, as a model relating each participant‚Äôs tea rating, <span class="math inline">\(Y_i\)</span>, given that participant‚Äôs treatment assignment, <span class="math inline">\(X_i\)</span>. <span class="math inline">\(X_i=0\)</span> represents the control (milk-first) group and <span class="math inline">\(X_i=1\)</span> represents the treatment (tea-first) group. Here, <span class="math inline">\(Y_i\)</span> is the dependent variable, and <span class="math inline">\(X_i\)</span> is the independent variable. <span class="math inline">\(i\)</span>s are an index variable for each of the participants. To make this concrete, you can see some sample tea-tasting data (N=24 for simplicity) below, with the index <span class="math inline">\(i\)</span>, the condition and its predictor <span class="math inline">\(X_i\)</span>, and the rating <span class="math inline">\(Y\)</span>.</p>
<div id="htmlwidget-916c5bc403e1f7b162d7" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-916c5bc403e1f7b162d7">{"x":{"filter":"none","caption":"<caption>Example tea tasting data in a regression format.<\/caption>","data":[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],["milk first","milk first","milk first","milk first","milk first","milk first","milk first","milk first","milk first","milk first","milk first","milk first","tea first","tea first","tea first","tea first","tea first","tea first","tea first","tea first","tea first","tea first","tea first","tea first"],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],[6,4,5,5,5,4,6,4,7,4,6,7,2,3,3,4,3,1,1,5,3,1,3,5]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>i<\/th>\n      <th>condition<\/th>\n      <th>X<\/th>\n      <th>rating (Y)<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[0,2,3]}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<p>Here‚Äôs the model:</p>
<!-- MBM to MCF: Let's discuss whether to switch to standard notation (e.g., betas) in this chapter or to stick with notation more like the previous chapter. I might lean toward using standard notation here and syncing earlier chapter with that notation. -->
<!-- MM: Not sure if align environment is supported in RMD. Might need to use this: https://stackoverflow.com/questions/47912278/align-environment-in-r-markdown-which-works-for-both-docx-and-pdf-output -->
<p><span class="math display">\[\begin{align}
\label{eq:ols_ttest}
Y_i &amp;= \theta_{milkfirst} + \beta X_i + \epsilon_i \\
\end{align}\]</span></p>
<p>A model like this is called a <strong>linear regression of Y on X</strong>. <span class="math inline">\(\theta_{milkfirst} + \beta X_i\)</span> is called the <strong>linear predictor</strong>, and it describes the expected value of an individual‚Äôs tea rating, <span class="math inline">\(Y_i\)</span>, given that participant‚Äôs treatment group <span class="math inline">\(X_i\)</span> (the single independent variable in this model). That is, for a participant in the control group (<span class="math inline">\(X_i=0\)</span>), the linear predictor is just equal to <span class="math inline">\(\theta_{milkfirst}\)</span>, which is indeed the mean for the control group that we specified above. On the other hand, for a participant in the treatment group, the linear predictor is equal to <span class="math inline">\(\theta_{milkfirst} + \beta\)</span>, which is the mean for the treatment group that we specified. In regression jargon, <span class="math inline">\(\beta\)</span> is a <strong>regression coefficient</strong>, representing the association of the independent variable <span class="math inline">\(X_i\)</span> with the outcome <span class="math inline">\(Y_i\)</span>.</p>
<p>The term <span class="math inline">\(\epsilon_i\)</span> is the <strong>error term</strong>, referring to random variation of participants‚Äô ratings around the group mean.<label for="tufte-sn-88" class="margin-toggle sidenote-number">88</label><input type="checkbox" id="tufte-sn-88" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">88</span> Formally, we‚Äôd write <span class="math inline">\(\epsilon_i &amp;\sim N(0, \sigma^2)\)</span>. The tilde means ‚Äúis distributed as,‚Äù and what follows is a normal distribution with mean 0 and variance <span class="math inline">\(\sigma^2\)</span>.</span> Note that this is a very specific kind of ‚Äúerror‚Äù; it not to ‚Äúerror‚Äù due to bias, for example. Instead, you can think of the error terms as capturing the ‚Äúerror‚Äù that would be associated with predicting any given participant‚Äôs rating based on just the linear predictor. If you thus predicted a control group participant‚Äôs rating as <span class="math inline">\(\theta_{milkfirst}\)</span>, this would be a good guess, but you still expect the participant‚Äôs rating to deviate somewhat from <span class="math inline">\(\theta_{milkfirst}\)</span> due to ‚Äúerror.‚Äù In this model, the linear predictor and error terms together say that participants‚Äô ratings scatter randomly (in fact, normally) around their group means with standard deviation <span class="math inline">\(\sigma\)</span>. And that is exactly the model we posited in Chapter <a href="5-estimation.html#estimation">5</a>.
<!-- [NOT TRUE BECAUSE PREVIOUS MODEL USED UNEQUAL VARIANCES.]  --></p>
<div class="figure"><span id="fig:models-ols-plot"></span>
<p class="caption marginnote shownote">
Figure 7.1: (left) Best-fitting regression coefficients for the tea-tasting experiment. (right) Much worse coefficients for the same data.
</p>
<img src="experimentology_files/figure-html/models-ols-plot-1.png" alt="(left) Best-fitting regression coefficients for the tea-tasting experiment. (right) Much worse coefficients for the same data." width="\linewidth"  />
</div>
<p>Now we have the model. How do we estimate the regression coefficients <span class="math inline">\(\theta_{milkfirst}\)</span> and <span class="math inline">\(\beta\)</span>? The usual method is called <strong>ordinary least squares (OLS)</strong>. Here‚Äôs the basic idea. For any given regression coefficient estimates <span class="math inline">\(\widehat{\theta}_{milkfirst}\)</span> and <span class="math inline">\(\widehat{\beta}\)</span>, we would obtain different <strong>predicted values</strong>, <span class="math inline">\(\widehat{Y}_i = \theta_{milkfirst} + \beta X_i\)</span> for each participant. Some regression coefficient estimates will yield better predictions than others. OLS estimation is designed to find the values of the regression coefficients that optimize these predictions, meaning that the predictions are as close as possible to participants‚Äô true outcomes, <span class="math inline">\(Y_i\)</span>.<label for="tufte-sn-89" class="margin-toggle sidenote-number">89</label><input type="checkbox" id="tufte-sn-89" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">89</span> Specifically, OLS minimizes squared error loss, in the sense that it will choose the regression coefficient estimates whose predictions minimize <span class="math inline">\(\sum_{i=1}^n \left( Y_i - \widehat{Y}_i\right)^2\)</span>, where <span class="math inline">\(n\)</span> is the sample size. A wonderful thing about OLS is that those optimal regression coefficients (generically termed <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span>) turn out to have a very simple closed form: <span class="math inline">\(\widehat{\mathbf{\beta}} = \left( \mathbf{X}&#39;\mathbf{X} \right)^{-1} \mathbf{X}&#39;\mathbf{y}\)</span>. We are using more general notation here because there could be multiple independent variables. Therefore, <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span> is a vector, <span class="math inline">\(\mathbf{X}\)</span> is a matrix of independent variables for each subject, and <span class="math inline">\(\mathbf{y}\)</span> is a vector of participants‚Äô outcomes. As more good news, the standard error for <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span> has a similarly simple closed form.</span></p>
<p>Figure <a href="7-models.html#fig:models-ols-plot">7.1</a> gives a graphical illustration of the tea tasting data for each condition (the dots) along with the model predictions for each condition <span class="math inline">\(\theta_{milkfirst}\)</span> and <span class="math inline">\(\theta_{milkfirst} + \beta\)</span> (blue lines). The distance of each point to the predictions (the thing that OLS wants to minimize) is shown by the dotted lines. Another name for these errors is <strong>residuals</strong>: they are the ‚Äúresidual variation‚Äù that is not predicted by the model.</p>
<p>The left-hand plot shows the best coefficient values ‚Äì the ones that move the model as close as possible to each point, minimizing the total squared length of the dashed lines. The right-hand plot shows a substantially worse solution. The amazing thing about OLS is that it is a simple way to find the best solution for a wide range of useful models.<label for="tufte-sn-90" class="margin-toggle sidenote-number">90</label><input type="checkbox" id="tufte-sn-90" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">90</span> You‚Äôll notice that we haven‚Äôt talked at all about <span class="math inline">\(p\)</span>-values in this chapter. Regression models can be used to produce <span class="math inline">\(p\)</span>-values on specific coefficients, representing inferences about the likelihood of a particular coefficient magnitude relative to some null hypothesis. You can also compute Bayes Factors on specific regression coefficients. We won‚Äôt talk much about either of these computations though. As we said, we‚Äôre not really trying to teach you statistics, just how to think about data!</span></p>
</div>
<div id="adding-predictors" class="section level3" number="7.1.2">
<h3><span class="header-section-number">7.1.2</span> Adding predictors</h3>
<p>The regresson model we just wrote down is the same thing as the <span class="math inline">\(t\)</span>-test from Chapter <a href="6-inference.html#inference">6</a>. But the beauty of regression modeling is that much more complex estimation problems than this can also be written as regression models, essentially by extending what we did above. For example, we might want to add another predictor variable, such as the age of the participant.<label for="tufte-sn-91" class="margin-toggle sidenote-number">91</label><input type="checkbox" id="tufte-sn-91" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">91</span> The ability to estimate multiple coefficients at once is a huge strength of regression modeling, so much so that sometimes people use the label <strong>multiple regression</strong> to denote that there is more than one predictor + coefficient pair.</span></p>
<p>Let‚Äôs add this new independent variable and a corresponding regression coefficient to our model:</p>
<p><span class="math display">\[\begin{align}
\label{eq:ols_one_covariate}
Y_i &amp;= \theta_{milkfirst} + \beta X_{i1} + \theta_{age} X_{i2}  + \epsilon_i \\
\end{align}\]</span>
<!-- \epsilon_i &\sim N(0, \sigma^2) -->
<!-- WHY ARE WE USING THETA FOR THE CONTINUOUS PREDICTORS INSTEAD OF BETA? --></p>
<p>Now that we have multiple independent variables, we‚Äôve labeled them <span class="math inline">\(X_{i1}\)</span> (treatment group) and <span class="math inline">\(X_{i2}\)</span> (age) for clarity.</p>
<p>To illustrate how to interpret the regression coefficients in this model, let‚Äôs use the linear predictor to compare the model‚Äôs predicted tea ratings for two hypothetical participants who are both in the treatment group: 20-year-old Alice and 21-year old Bob. Alice‚Äôs linear predictor tells us that her expected rating is <span class="math inline">\(\theta_{milkfirst} + \beta + \theta_{age} \cdot 20\)</span>. In contrast, Bob‚Äôs linear predictor is <span class="math inline">\(\theta_{milkfirst} + \beta + \theta_{age} \cdot 21\)</span>. We could therefore calculate the expected difference in ratings for 21-year-olds versus 20-year olds by subtracting Alice‚Äôs linear predictor from Bob‚Äôs, yielding just <span class="math inline">\(\theta_{age}\)</span>. How simple!</p>
<p>In fact, we would get the same result if Alice and Bob were instead 50 and 51 years old, respectively. Try this yourself. This equivalence illustrates a key point about linear regression models in general: <em>the regression coefficient represents the mean (i.e., expected) difference in <span class="math inline">\(Y_i\)</span> when comparing participants who differ by 1 unit of the corresponding independent variable</em> (here, comparing participants who differ by 1 year of age). In ‚ÄúPractical modeling considerations‚Äù below, we discuss whether and when to ‚Äúcontrol for‚Äù additional variables (i.e., when to add them to your model) .</p>
</div>
<div id="when-does-linear-regression-work" class="section level3" number="7.1.3">
<h3><span class="header-section-number">7.1.3</span> When does linear regression work?</h3>
<p>Linear regression modeling with OLS is an incredibly powerful technique for creating models to estimate the influence of multiple predictors on a single dependent variable. In fact, OLS is in a mathematical sense the <em>best</em> way to fit a linear model!<label for="tufte-sn-92" class="margin-toggle sidenote-number">92</label><input type="checkbox" id="tufte-sn-92" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">92</span> There is a precise sense in which OLS gives the <em>very best</em> predictions we could ever get from any model that posits linear relationships between the independent variables and the outcome. That is, you can come up with any other linear model you want, and yet if the assumptions of OLS are fulfilled, predictions from OLS will always be less noisy than those of your model. This is because of an elegant mathematical result called the Gauss-Markov Theorem.</span> But OLS only ‚Äúworks‚Äù ‚Äì in the sense of yielding good estimates ‚Äì if three big conditions are met.</p>
<ol style="list-style-type: decimal">
<li><strong>The predictor relationships being modeled must be linear.</strong> In our comparison of Alice‚Äôs and Bob‚Äôs expected outcomes based on their 1-year age difference, we were able to interpret the coefficient <span class="math inline">\(\theta_{age}\)</span> as the average difference in <span class="math inline">\(Y_i\)</span> when comparing participants who differ by 1 year of age, <em>regardless</em> of whether those ages are 20 vs.¬†21 or 50 vs.¬†51. But that‚Äôs not always true: plenty of things vary <strong>non-linearly</strong> with age ‚Äì for example, imagine growth in height over age! Linear regression will give bad answers in such cases.<label for="tufte-sn-93" class="margin-toggle sidenote-number">93</label><input type="checkbox" id="tufte-sn-93" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">93</span> One way to accommodate <strong>nonlinearities</strong> is to modify the linear predictor to include polynomial terms, such as <span class="math inline">\(age^2\)</span>, which then allow us to fit a curve rather than just a straight line. It is always a good idea to use visualizations like scatterplots to look for possible problems with linearity.</span></li>
</ol>
<!-- [Suggested Figure. Panel A: Scatterplot showing a nice linear relationship with OLS fit superimposed. Panel B: Scatterplot showing a nonlinear relationship with OLS fit, OLS fit with x^2 term, and LOESS superimposed.] -->
<ol start="2" style="list-style-type: decimal">
<li><strong>Errors must be independent.</strong> In our example, observations in the regression model (i.e., rows in the dataset) were sampled independently: each participant was recruited independently to the study and each performed a single trial. On the other hand, suppose we have repeated-measures data in which we sample participants, and then obtained multiple measurements for each participant. Within each participant, measurements would likely be correlated (perhaps due to their general level of tea enjoyment). This correlation in turn invalidates inferences from a model that does not include it.</li>
</ol>
<!-- Usually, outcome measurements within a participant will be correlated: if we measure 10 participants' blood pressures every day for a week, some participants will typically have high values whereas others will typically have low values, even though any given participant will also have some variation in their own measurements over time.[^models-3] To help identify such situations, it can be helpful to plot the distribution of **residuals** for each participant (or a random sample thereof) to see whether this distribution seems to differ across participants.  -->
<!-- [^models-3] To be specific, it is not the blood pressure values ($Y_i$) themselves that must be independent, but rather the error terms ($\epsilon$). The error terms are what is "left over" after accounting for systematic variation that is predicted by the independent variables. If, in principle, we managed to include in the linear predictor all variables that might explain individual differences in typical blood pressure (e.g., genetic factors, sex, age, etc.), then the errors would be independent even though the outcomes themselves are not. However, as a heuristic, considering possible sources of correlation in the outcomes themselves is often a reasonable proxy for thinking about the error terms. -->
<!-- [Suggested Figure. Violin plots, or similar, showing residuals for different subjects. The residuals exhibit non-independence.] -->
<ol start="3" style="list-style-type: decimal">
<li><strong>Errors must be normal and unrelated to the predictor.</strong> Imagine older people have very strong tea-ordering preferences while younger people do not. In that case, the models‚Äô error term would be more variable for older participants than younger ones. This issue is called <strong>heteroskedasticity</strong>. It is a good idea to plot each independent variable versus the residuals to see if the residuals are more variable for certain values of the independent variable than for others.</li>
</ol>
<p><!-- This is often the case for highly skewed outcome variables. For example, if we regressed participants' incomes on their years of education, we will find that higher education is associated with higher income. However, because income is highly right-skewed in many samples (some people have extremely high incomes), income will typically be more variable for individuals with more education than for those with less education. For this reason, if we predicted incomes for individuals with 16 years of education (i.e., they completed 4-year college and then stopped) and also for individuals with 8 years (i.e., they completed middle school and then stopped), the errors in the former predictions will probably be more variable than the errors in the latter predictions.  --></p>
<!-- [Suggested Figure. X vs. residuals, showing heteroskedasticity.] -->
<p>If any of these three conditions are violated, estimates and inferences from your model may be suspect.</p>
</div>
</div>
<div id="generalized-linear-models" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> Generalized linear models</h2>
<p>So far we have considered continuous outcome measures, like tea ratings. What if we instead had a binary outcome, such as whether a participant liked or didn‚Äôt like the tea, or a count outcome, such as the number of cups a participant chose to drink? These and other non-continuous outcomes often violate the assumptions of OLS, in particular because they often induce heteroskedastic errors. For example, count outcomes are often right-skewed because a count cannot be less than 0, creating heteroskedasticity for the same reasons discussed above when we considered skewed continuous outcomes. Binary outcomes inherently violate heteroskedasticity because the variance of a binary variable depends directly on the success probability; this means that the errors will be more variable for individuals whose covariate values place their expected success probability closer to 0.50.[^models-4]</p>
<p>Happily, there are regression models closely related to OLS that can handle non-continuous outcomes. These models are called <strong>generalized linear models</strong> (GLM), and OLS is one of many members of this large class of models. To see the connection, let‚Äôs first write an OLS model more generally in terms of what it says about the expected value of the outcome:</p>
<p><span class="math display">\[\begin{align}
\label{eq:ols_general_form}
E[Y_i] &amp;= \beta_0 + \sum_{j=1}^p \beta_j X_j
\end{align}\]</span>
where <span class="math inline">\(p\)</span> is the number of independent variables, <span class="math inline">\(\beta_0\)</span> is the intercept, and <span class="math inline">\(\beta_j\)</span> is the regression coefficient for the <span class="math inline">\(j^{th}\)</span> independent variable.</p>
<p>The linear predictor of a GLM (i.e., <span class="math inline">\(\beta_0 + \sum_{j=1}^p \beta_j X_j\)</span>) looks exactly the same as for OLS, but instead of modeling <span class="math inline">\(E[Y_i]\)</span>, a GLM models some <strong>transformation</strong>, <span class="math inline">\(g(.)\)</span>, of the expectation:[^models-5]</p>
<p><span class="math display">\[\begin{align}
\label{eq:glm_general_form}
g( E[Y_i] ) &amp;= \beta_0 + \sum_{j=1}^p \beta_j X_j 
\end{align}\]</span></p>
<p>It turns out that by choosing a transformation of <span class="math inline">\(E[Y_i]\)</span> that is suitable for the outcome type, we can still fit a linear model. This transformation is called the <strong>link function</strong>. For example, <span class="math inline">\(g(x) = log(x)\)</span> is usually a suitable link function for count or binary outcomes. GLMs also handle the error terms differently from OLS, but we won‚Äôt cover that here. We have only scratched the surface of GLMs here, but the take-home point is simply that they are usually the tool of choice for fitting regression models with non-continuous outcomes.</p>
<p>[^models-4] Specifically, the variance of a binary variable with success probability <span class="math inline">\(p\)</span> is simply <span class="math inline">\(p(1-p)\)</span>, which is maximized at <span class="math inline">\(p=0.50\)</span>.</p>
<p>[^models-5] Note that GLMs involve transforming the <em>expectation</em> of the outcome, not the outcome itself! That is, we are not just taking the outcome variable in our dataset and transforming it before fitting an OLS model, but rather we are fitting a different model entirely, one that posits a fundamentally different relationship between the predictors and the expected outcomes.</p>
</div>
<div id="accommodating-clustering-in-our-models" class="section level2" number="7.3">
<h2><span class="header-section-number">7.3</span> Accommodating clustering in our models</h2>
<p>As noted above, another common situation in which the assumptions of OLS are violated is when the error terms are not independent, for example in repeated-measures data in which participants‚Äô error terms across time points are likely to be clustered. We will discuss two classes of methods for accommodating clustering in regression.</p>
<div id="linear-mixed-models" class="section level3" number="7.3.1">
<h3><span class="header-section-number">7.3.1</span> Linear mixed models</h3>
<p>The first class of methods is <strong>linear mixed models</strong> (LMM). In this approach, we modify the linear predictor itself to model differences across clusters. Suppose we modified the original tea-tasting experiment (without the age covariate) to collect repeated ratings from each participant, such that each participant tastes 5 milk-first and 5 tea-first cups. Then we could fit a LMM as follows:</p>
<p><span class="math display">\[\begin{align}
\label{eq:lmm}
Y_i &amp;= \theta_{milkfirst} + \gamma_i + \beta X_{it} + \epsilon_{it} \\
\gamma_i \sim N(0, \tau^2) \\
\epsilon_{it} &amp;\sim N(0, \sigma^2) \\
\end{align}\]</span></p>
<p>where <span class="math inline">\(Y_{it}\)</span> is participant <span class="math inline">\(i\)</span>‚Äôs rating in trial <span class="math inline">\(t\)</span> and <span class="math inline">\(X_{it}\)</span> is the participant‚Äôs assigned treatment in trial <span class="math inline">\(t\)</span> (i.e., milk-first or tea-first). Compare this model to the basic OLS model in Equation (). Here we‚Äôve introduced another intercept coefficient, <span class="math inline">\(\gamma_i\)</span>, and it‚Äôs unlike the original intercept <span class="math inline">\(\theta_{milkfirst}\)</span> in that <span class="math inline">\(\gamma_i\)</span> varies across participants. As such, <span class="math inline">\(\gamma_i\)</span> is a <strong>random intercept</strong>, whereas <span class="math inline">\(\theta_{milkfirst}\)</span> is a <strong>fixed intercept</strong>. Specifically, we have assumed that each participant has their own typical ‚Äúbaseline‚Äù tea rating ‚Äì some participants generally like tea more than others ‚Äì and that these baseline ratings are normally distributed across participants. Thus, ratings are correlated within participants because ratings cluster around each participant‚Äôs <em>unique</em> baseline tea rating. LMMs can be further extended to model clustering of the independent variables‚Äô effects across subjects. To do so, we could introduce <strong>random slopes</strong> (<span class="math inline">\(\gamma_i\)</span>) to the model, which represent differences across participants in the effects of independent variables:</p>
<p><span class="math display">\[\begin{align}
\label{eq:lmm}
Y_i &amp;= \theta_{milkfirst} + \gamma_i + \beta X_{it} + \gamma_j + X_{i1} + \epsilon_{it} \\
\gamma_i \sim N(0, \tau^2) \\
\epsilon_i &amp;\sim N(0, \sigma^2) \\
\end{align}\]</span></p>
<p>LMM is powerful and is a very common approach in psychology, but it does have limitations. Its validity relies on our ability to correctly specify the structure of the random intercepts and errors. This is particularly problematic when the correlation structure of the errors is misspecified, for example if observations within a participant are more correlated for participants in the treatment group than in the control group; in such cases, LMM estimates can be substantially biased <span class="citation">(<a href="#ref-bie2021fitting" role="doc-biblioref">Bie et al., 2021</a>)</span>. It can be difficult to verify if the model specification is reasonable, especially with a small number of clusters or observations. Even if the model is correctly specified, LMM can severely underestimate standard errors (e.g., yielding too-small <span class="math inline">\(p\)</span>-values) if the number of clusters is not large.[^models-6]</p>
</div>
<div id="an-alternative-approach-generalized-estimating-equations" class="section level3" number="7.3.2">
<h3><span class="header-section-number">7.3.2</span> An alternative approach: Generalized estimating equations</h3>
<p>A second class of methods that helps resolve these issues is <strong>generalized estimating equations</strong> (GEE). In this approach, we leave the linear predictor alone. We do not add random intercepts or slopes, nor do we assume anything about the distribution of the errors (i.e., we no longer assume that they are normal, independent, and homoskedastic). We instead provide the model with an initial ‚Äúguess‚Äù about how we think the errors might be related to one another; for example, in a repeated-measures experiment, we might guess that the errors are exchangeable, meaning that they are correlated to the same degree within each participant but are uncorrelated across participants. Instead of <em>assuming</em> that our guess is correct, as does LMM, GEE estimates the correlation structure of the errors empirically, using our guess as a starting point, and it uses this correlation structure to arrive at point estimates and inference for the regression coefficients. Remarkably, as the number of clusters and observations become very large, GEE will <em>always</em> provide unbiased point estimates and valid inference, <em>even if</em> our guess about the correlation structure was bad. Additionally, with simple finite-sample corrections <span class="citation">(<a href="#ref-mancl2001covariance" role="doc-biblioref">Mancl &amp; DeRouen, 2001</a>)</span>, GEE seems to provide valid inference at smaller numbers of clusters than does LMM. The price paid for these nice safeguards against model misspecification is that, in principle, GEE will typically have less statistical power than LMM <em>if</em> the LMM is in fact correctly specified, but the difference may be surprisingly slight in practice <span class="citation">(<a href="#ref-bie2021fitting" role="doc-biblioref">Bie et al., 2021</a>)</span>. For these reasons, we tend to prefer GEE with finite-sample corrections over LMM as the default model for clustered data. In general, we tend to favor LMM over GEE only when the number of observations and clusters are quite large, and when careful diagnostics also indicate that distributional assumptions are fulfilled.</p>
<p>[MBM to MCF: Above is what I usually say as my default recommendation for GEE vs.¬†LMM, but happy to discuss and modify if you don‚Äôt agree. I also haven‚Äôt touched the marginal vs.¬†conditional interpretation issue since this has been about LMM and not GLMM.]</p>
<p>[^models-6] How many clusters are enough for LMM to behave well? This is an active area of research, and the answer will depend on the number of observations in each cluster and the model structure. However, some empirical findings suggest that, at least for certain models, LMM can considerably underestimate standard errors even with, for example, 20 clusters each with 100 observations <span class="citation">(<a href="#ref-bie2021fitting" role="doc-biblioref">Bie et al., 2021</a>)</span>.</p>
</div>
</div>
<div id="how-do-you-use-models-to-analyze-data" class="section level2" number="7.4">
<h2><span class="header-section-number">7.4</span> How do you use models to analyze data?</h2>
<p>Estimating one quantity in isolation is often not the best thing to do. In almost any experiment, there will be variation in the estimate that has to do with other known sources. Imagine the Stroop effect, which has a fairly consistent effect on both fast and slow readers <span class="citation">(<a href="#ref-haaf2017" role="doc-biblioref">Haaf &amp; Rouder, 2017</a>)</span>. But estimates of this effect will be more precise if we take into account that some readers are slower or faster, rather than just averaging across all this variation. That‚Äôs why we need models that take into account different sources of variation.</p>
<p><strong>Make a simple model</strong> that includes all of the key parts of the design (link to visualization).</p>
<p><strong>don‚Äôt muck up your causal inference</strong></p>
<p><strong>check the model against the data</strong></p>
<p><strong>interpret the predictions of the model</strong></p>
<div id="when-does-it-makes-sense-to-include-covariates-in-a-model" class="section level3" number="7.4.1">
<h3><span class="header-section-number">7.4.1</span> When does it makes sense to include covariates in a model?</h3>
<ul>
<li>adjusting models for unhappy randomization?</li>
</ul>
<p>Going back to our example, now we have two variables ‚Äì age and order ‚Äì that are no longer confounded with our primary relationship of interest (i.e., Dylan and writing). But they may still be related to our outcome measure. Here‚Äôs what the picture looks like, repeated from above.</p>
<p>Even if they are not confounding our experimental manipulation, age and experimental condition order may still be correlated with our outcome measure, writing skill. How does this work? Well, the average treatment effect of Dylan on writing is still given by the regression Y ~ X. But we also know that there is some variance in Y that is due to X‚Äô and Z.</p>
<p>That‚Äôs because age and order are covariates: they may ‚Äì by virtue of their potential causal links with the outcome variable ‚Äì have some correlation with outcomes, even in a case where the predictor is experimentally manipulated. This should be intuitive for the external (age) covariate, but it‚Äôs true for both: they may account for variance in Y over and above that controlled by the experimental manipulation of X.</p>
<p>What should we do about our covariates?</p>
<p>Option 1. Nothing! We are totally safe in ignoring all of our covariates, regressing Y on X and treating the estimate as an unbiased estimate of the the effect (the ATE). This is why randomization is awesome. We are guaranteed that, in the limit of many different experiments, even though people with different ages will be in the different Dylan conditions, this source of variation will be averaged out.</p>
<p>The first fallacy of covariates is that, because you have a known covariate, you have to adjust for it. Not true. You can just ignore it and your estimate of the ATE is unbiased. This is the norm in cognitive psychology, for example: variation between individuals is treated as noise and averaged out. Of course, there are weaknesses in this strategy ‚Äì you will not learn about the relationship of your treatment to those covariates! ‚Äì but it is sound.</p>
<p>Option 2. If you have a small handful of covariates that you believe are meaningfully related to the outcome, you can plan in advance to adjust for them in your regression. In our Dylan example, this would be a pre-registered plan to add Z as a predictor: Y ~ X + Z. If age (Z) is highly correlated with writing ability (Y), then this will give us a more precise estimate of the ATE, while remaining unbiased.</p>
<p>When should we do this? Well, it turns out that you need a pretty strong correlation to make a big difference. There‚Äôs some nice code to simulate the effects of covariate adjustment on precision in this useful blogpost on covariate adjustment; I lightly adapted it. Here‚Äôs the result:</p>
<p>Root mean squared error (RMSE; lower RMSE means greater precision, in other words) is plotted as a function of the sample size (N). Different colors show the increase in precision when you control for covariates with different levels of correlation with the outcome variable. For low levels of correlation with the covariate, you don‚Äôt get much increase in precision (pink and red lines). Only as the correlation is .6 or above do we see noticeable increases in precision; and it only really makes a big difference with correlations in the range of .8.</p>
<p>Considering these numbers in light of our Dylan study, I would bet that age and writing skill are not correlated with writing skill &gt; .8 (unless we‚Äôre looking at ages from kindergarten to college!). I would guess that in an adult population this correlation would be much, much lower. So maybe it‚Äôs not worth controlling for age in our analyses.</p>
<p>And the same is probably true for order, our other covariate. Although perhaps we do think that our order has a strong correlation with our skill measure. For example, maybe our experiment is long and there are big fatigue effects. In that case, we would want to condition.</p>
<p>So these are are options: if the covariate is known to be very strong, we can condition. Otherwise we should probably not worry about it.</p>
<p>What shouldn‚Äôt we do with our covariates?</p>
<p>Don‚Äôt condition on lots and lots of covariates because you think they are theoretically important. There are lots of things that people do with covariates that they shouldn‚Äôt be doing. My participantal hunch is that this is because a lot of researchers think that covariates (especially demographic ones like age, gender, socioeconomic status, race, ethnicity, etc.) are important. That‚Äôs true: these are important variables. But that doesn‚Äôt mean you need to control for them in every regression. This leads us to the second fallacy.</p>
<p>The second fallacy of covariates is that, because you think covariates are in general meaningful, it is not harmful to control for them in your regression model. In fact, if you control for meaningless covariates in a standard regression model, you will on average reduce your ability to see differences in your treatment effect. Just by chance your noise covariates will ‚Äúsoak up‚Äù variation in the response, leaving less to be accounted for by the true treatment effect! Even if you strongly suspect something is a covariate, you should be careful before throwing it into your regression model.</p>
<p>Don‚Äôt condition on covariates because your groups are unbalanced. People often talk about ‚Äúunhappy randomization‚Äù: you randomize adults to the different Dylan groups, for example, but then it turns out the mean age is a bit different between groups. Then you do a t-test or some other statistical test and find out that you actually have a significant age difference. But this makes no sense: because you randomized, you know that the difference in ages occurred by chance, so why are you using a t-test to test if the variation is due to chance? In addition, if your covariate isn‚Äôt highly correlated with the outcome, this difference won‚Äôt matter (see above). Finally, if you adjust for this covariate because of such a statistical test, you can actually end up biasing estimates of the ATE across the literature. Here‚Äôs a really useful blogpost from the Worldbank that has more details on why you shouldn‚Äôt follow this practice.</p>
<p>Don‚Äôt condition on covariates post-hoc. The previous example is a special case of a general practice that you shouldn‚Äôt follow. Don‚Äôt look at your data and then decide to control for covariates! Conditioning on covariates based on your data is an extremely common route for p-hacking; in fact, it‚Äôs so common that it shows up in Simmons, Nelson, &amp; Simonsohn‚Äôs (2011) instant classic False Positive Psychology paper as one of the key ingredients of analytic flexibility. Data-dependent selection of covariates is a quick route to false positive findings that will be less likely to be replicable in independent samples.</p>
<p>Don‚Äôt condition on a post-treatment variable. As we discussed above, there are some reasons to condition on highly-correlated covariates in general. But there‚Äôs an exception to this rule. There are some variables that are never OK to condition on ‚Äì in particular, any variable that is collected after treatment. For example, we might think that another good covariate would be someone‚Äôs enjoyment of Bob Dylan. So, after the writing measurements are done, we do a Dylan Appreciation Questionnaire (DAQ). The problem is, imagine that having a bad experience writing while listening to Dylan might actually change your DAQ score. So then people in the Dylan condition would have lower DAQ on average. If we control for DAQ in our regression (Y ~ X + DAQ), we then distort our estimate of the effects of Dylan. Because DAQ and X (Dylan condition) are correlated, DAQ will end up soaking up some variance that is actually due to condition. This is bad news. Here‚Äôs a nice paper that explains this issue in more detail.</p>
<p>Don‚Äôt condition on a collider. This issue is a little bit off-topic for the current post, since it‚Äôs primarily an issue in observational designs, but here‚Äôs a really good blogpost about it.</p>
<p>Covariates and confounds are some of the most basic concepts underlying experimental design and analysis in psychology, yet they are surprisingly complicated to explain. Often the issues seem clear until it comes time to do the data analysis, at which point different assumptions lead to different default analytic strategies. I‚Äôm especially concerned that these strategies vary by culture, for example with some psychologists always conditioning on confounders, and others never doing so. (We haven‚Äôt even talked about mediation and moderation!). Hopefully this post has been useful in using the vocabulary of causal models to explain some of these issues.</p>
<!-- ## Connection to Bayesian approaches -->
<!-- * Say that what we have covered so far is essentially just the likelihood; formalize the intuition from "Estimation" about Bayesian inference to show how a prior affects the model specification -->
</div>
</div>
<div id="chapter-summary-models" class="section level2" number="7.5">
<h2><span class="header-section-number">7.5</span> Chapter summary: Models</h2>
<!-- structure in your data so that you can better estimate the particular effects of interest. -->
<!-- *** The advice not to model covariates that aren't very correlated with your outcome is very frequentist, with the idea being that you lose power when you condition on too many things. In contrast, Gelman & Hill (2006) give more Bayesian advice: if you think a variable matters to your outcome, keep it in the model. This advice is consistent with the idea of modeling experimental covariates, even if they don't have a big correlation with the outcome. In the Bayesian framework, including this extra information should (maybe only marginally) improve your precision but you aren't "spending degrees of freedom" in the same way. -->
<!-- ## FROM PREVIOUS STRUCTURE: Inference and estimation for two-group designs -->
<!-- Throughout this book we've taken the position that the goal of experiments is to estimate a causal effect of interest, ideally as part of some theory of how different constructs relate to one another. All this talk of hypotheses and inferences above is only indirectly related to that goal.  -->
<!-- - Intuition builder: For very large n, or flat prior, Bayes and frequentist coincide.  -->
<!-- ### Simple models of between-group differences -->
<!-- Introducing simple inference models: -->
<!-- - The chi-squared test for inferring whether two samples come from the same distribution -->
<!-- - The t-test for inferring whether a single group‚Äôs effect differs from 0 -->
<!-- - The t-test for inferring whether two groups differ from one another -->
<!-- - The paired t-test as a first glimpse at how we might account for participant-level random effects (see Chapter 7). -->
<!-- ::: {.accident-report} -->
<!-- ‚ö†Ô∏è Accident report: Once you have the basic t-test under your belt, it might feel natural to compare each group to 0 and conclude that one group is different from 0 and the other one isn‚Äôt. But ‚Äúthe difference between significant and not significant is not necessarily itself statistically significant‚Äù (Nieuwenhuis, Forstmann, and Wagenmakers 2011).  -->
<!-- ::: -->
<!-- How to go from theory to hypotheses to statistical model -->
<!-- Re-casting the t-test as a regression model  -->
<!-- ::: {.interactive} -->
<!-- ‚å®Ô∏è Interactive box: Visualizing how different tests are variants of linear models. -->
<!-- ::: -->
<!-- - Discrete data and logistic regression. Same thing, different linking function. (lead-in to GLM: probit, Poisson, beta, etc.). -->
<!-- Multilevel regression models of a difference between two groups, controlling for experimental items and subject -->
<!--   - Sidebar: what should you control for? Different subcultures in psychology either post-hoc control for or look for moderation by demographic factors. We discuss the consequences of these decisions for both precision and causal inference.  -->
<!-- Causality revisited: what can and can‚Äôt be concluded from an experiment -->
<!-- ::: {.accident-report} -->
<!-- ‚ö†Ô∏è Accident report: Mediation going wrong: even when you have a randomized experiment, you can still mess up your causal inference (Montgomery, Nyhan, and Torres 2018).  -->
<!-- ::: -->
<!-- - Dropping subjects who fail a manipulation check can be problematic (Aronow, Baron, and Pinson 2019). -->
<!-- - Mediation requires more confounding assumptions than causal inference about total effects, and these assumptions may be violated even in randomized experiments.  -->
<!-- ### Homeless -->
<!-- ‚å®Ô∏è Interactive box: non-parametric simulations where you can shuffle data across groups a bunch of times and see what kind of distribution it produces by chance -->
<!-- ::: {.interactive} -->
<!-- ‚å®Ô∏è Interactive: Nonparameteric resampling under the null -->
<!-- As we've seen above, hypothesis testing hinges on approximating the null distribution of the statistical estimate. In the examples above, it was easy to use statistical theory to work out the null distribution: for example, in Figure \@ref(fig:inference-null-model), we knew that the null distribution must be binomial since we had a binary outcome, and the binomial distribution parameter $p$ must be 0.5, because that is what the null says.  -->
<!-- But sometimes we don't know what the null distribution would look like. Suppose we want to estimate group differences in a highly skewed continuous outcome, like salary, but we had a small sample size (e.g., $n=10$ per group): -->
<!-- ```{r inference-permutation-1, eval=FALSE} -->
<!-- print(d) -->
<!-- set.seed(451) -->
<!-- n.per.group = 10 -->
<!-- d = data.frame( Y = c( rexp( n = n.per.group, rate = 4 ), -->
<!--                        rexp( n = n.per.group, rate = 4 ) + 0.3 ), -->
<!--                 Group = c( rep( "Control", n.per.group ), -->
<!--                            rep ( "Treatment", n.per.group ) ) ) -->
<!-- colors = c("black", "orange") -->
<!-- ggplot( data = d, -->
<!--         aes(x = Y, group = Group ) ) + -->
<!--   #geom_histogram( aes(fill = Group), alpha = 0.4 ) + -->
<!--   geom_dotplot( aes( fill=Group ), alpha=0.4, binwidth = .05 ) + -->
<!--   scale_y_continuous(NULL, breaks = NULL) + -->
<!--   theme_bw() + xlab("Y") + -->
<!--   ylab("")  -->
<!-- ``` -->
<!-- We can't proceed with a t-test in good conscience because, with only $n=20$, we can't necessarily trust that the Central Limit Theorem has "kicked in" sufficiently for the test to work despite the skewness. Stated otherwise, we can't be sure that the null distribution is normal in this case.  -->
<!-- When we can't rely on theory, another way to approximate a null distribution is through nonparameteric resampling. "Resampling" means that we're going to cleverly draw new samples *from our existing sample*, and "nonparametric" means that we will do this in a way that obviates assumptions about the shape of the null distribution (in contrast to parameteric approaches that do rely on such assumptions). -->
<!-- The central idea is that, if the treatment truly had no effect on the outcome, then the observations would be *exchangeable* between the treatment and control groups. That is, there would not be systematic differences between the treatment and control groups. This may or may not be true in our observed sample (after all, that's why we're doing a hypothesis test in the first place), but we could draw new samples from our existing sample in a manner that forces exchangeability. In this case, we could randomly permute the column of outcomes in our dataset while leaving the column of treatment assignments fixed: -->
<!-- ```{r inference-permutation-2, eval=FALSE} -->
<!-- # show construction of a single permuted dataset -->
<!-- # library(modelr) -->
<!-- # library(purrr) -->
<!-- perm.reps = 100 -->
<!-- perms = permute(data = d, n = perm.reps, Y) -->
<!-- # show the first permuted dataset -->
<!-- print( perms$perm[[1]]$data ) -->
<!-- #@WHY ARE THESE ALL THE SAME?? -->
<!-- cbind( perms$perm[[1]]$data$Y, perms$perm[[2]]$data$Y ) -->
<!-- # c.f. package example for debugging -->
<!-- perms2 <- permute(mtcars,  1000, mpg) -->
<!-- cbind( perms2$perm[[1]]$data$mpg, perms2$perm[[2]]$data$mpg ) -->
<!-- # also the same??  -->
<!-- # get group mean differences for each permutation via OLS -->
<!-- ols = map(perms$perm, ~ lm(Y ~ 1, data = .)) -->
<!-- ATEs = lapply( ols, function(.ols) as.numeric( coef(.ols)["(Intercept)"] ) ) -->
<!-- # now plot the ATEs to show the null sampling distribution -->
<!-- ``` -->
<!-- ::: -->

</div>
</div>



<h3>References</h3>
<div id="refs" class="references csl-bib-body hanging-indent" line-spacing="2">
<div id="ref-baddeley1975" class="csl-entry">
Baddeley, A. D., Thomson, N., &amp; Buchanan, M. (1975). Word length and the structure of short-term memory. <em>Journal of Verbal Learning and Verbal Behavior</em>, <em>14</em>(6), 575‚Äì589.
</div>
<div id="ref-bie2021fitting" class="csl-entry">
Bie, R., Haneuse, S., Huey, N., Schildcrout, J., &amp; McGee, G. (2021). Fitting marginal models in small samples: A simulation study of marginalized multilevel models and generalized estimating equations. <em>Statistics in Medicine</em>, <em>40</em>(24), 5298‚Äì5312.
</div>
<div id="ref-clark1973" class="csl-entry">
Clark, H. H. (1973). The language-as-fixed-effect fallacy: A critique of language statistics in psychological research. <em>Journal of Verbal Learning and Verbal Behavior</em>, <em>12</em>(4), 335‚Äì359.
</div>
<div id="ref-haaf2017" class="csl-entry">
Haaf, J. M., &amp; Rouder, J. N. (2017). Developing constraint in bayesian mixed models. <em>Psychological Methods</em>, <em>22</em>(4), 779.
</div>
<div id="ref-lovatt2000" class="csl-entry">
Lovatt, P., Avons, S. E., &amp; Masterson, J. (2000). The word-length effect and disyllabic words. <em>The Quarterly Journal of Experimental Psychology: Section A</em>, <em>53</em>(1), 1‚Äì22.
</div>
<div id="ref-mancl2001covariance" class="csl-entry">
Mancl, L. A., &amp; DeRouen, T. A. (2001). A covariance estimator for GEE with improved small-sample properties. <em>Biometrics</em>, <em>57</em>(1), 126‚Äì134.
</div>
<div id="ref-westfall2015" class="csl-entry">
Westfall, J., Judd, C. M., &amp; Kenny, D. A. (2015). Replicating studies in which samples of participants respond to samples of stimuli. <em>Perspectives on Psychological Science</em>, <em>10</em>(3), 390‚Äì399.
</div>
</div>
<p style="text-align: center;">
<a href="6-inference.html"><button class="btn btn-default">Previous</button></a>
<a href="8-measurement.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>

<script src="toc/toc.js"></script>


</body>
</html>
